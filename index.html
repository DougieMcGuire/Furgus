<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Canvas GIF Control</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      background: #000;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      color: white;
      font-family: Arial, sans-serif;
    }

    .intro-container {
      text-align: center;
    }

    #gifCanvas {
      max-width: 800px;
      width: 90vw;
      height: auto;
      border: 1px solid #333;
    }

    .controls {
      margin-top: 20px;
    }

    button {
      background: #333;
      color: white;
      border: 1px solid #666;
      padding: 10px 20px;
      margin: 0 10px;
      cursor: pointer;
      border-radius: 4px;
    }

    button:hover {
      background: #555;
    }

    .status {
      margin-top: 10px;
      color: #ccc;
    }
  </style>
</head>
<body>
  <div class="intro-container">
    <canvas id="gifCanvas"></canvas>
    
    <div class="controls">
      <button onclick="gifController.play()">Play</button>
      <button onclick="gifController.pause()">Pause</button>
      <button onclick="gifController.freezeLastFrame()">Freeze Last Frame</button>
    </div>
    
    <div class="status" id="status">Loading GIF...</div>
  </div>

  <script>
    class GIFController {
      constructor(canvasId, gifUrl) {
        this.canvas = document.getElementById(canvasId);
        this.ctx = this.canvas.getContext('2d');
        this.gifUrl = gifUrl;
        this.isPlaying = false;
        this.currentFrame = 0;
        this.frames = [];
        this.frameDelay = 100; // milliseconds between frames
        this.animationId = null;
        
        this.loadGIF();
      }
      
      async loadGIF() {
        try {
          // For this demo, we'll simulate frames since we can't parse actual GIF frames easily
          // In a real implementation, you'd use a library like gif.js or libgif-js
          
          const img = new Image();
          img.crossOrigin = 'anonymous';
          
          img.onload = () => {
            this.canvas.width = img.width;
            this.canvas.height = img.height;
            
            // Simulate multiple frames (you'd extract these from the actual GIF)
            this.createSimulatedFrames(img);
            this.updateStatus('GIF loaded. Ready to play.');
          };
          
          img.src = this.gifUrl;
          
        } catch (error) {
          console.error('Failed to load GIF:', error);
          this.updateStatus('Failed to load GIF');
        }
      }
      
      createSimulatedFrames(img) {
        // This simulates frame extraction - you'd use a proper GIF parser in reality
        for (let i = 0; i < 30; i++) { // Simulate 30 frames
          const frameCanvas = document.createElement('canvas');
          frameCanvas.width = img.width;
          frameCanvas.height = img.height;
          const frameCtx = frameCanvas.getContext('2d');
          
          // Draw with slight variations to simulate animation frames
          frameCtx.save();
          frameCtx.translate(img.width / 2, img.height / 2);
          frameCtx.rotate((i * Math.PI) / 180); // Rotate each frame slightly
          frameCtx.scale(0.8 + (i * 0.01), 0.8 + (i * 0.01)); // Scale up
          frameCtx.translate(-img.width / 2, -img.height / 2);
          frameCtx.drawImage(img, 0, 0);
          frameCtx.restore();
          
          this.frames.push(frameCanvas);
        }
        
        // Show first frame
        this.drawFrame(0);
      }
      
      play() {
        if (this.isPlaying) return;
        
        this.isPlaying = true;
        this.currentFrame = 0;
        this.updateStatus('Playing...');
        this.animate();
      }
      
      pause() {
        this.isPlaying = false;
        if (this.animationId) {
          cancelAnimationFrame(this.animationId);
        }
        this.updateStatus('Paused');
      }
      
      animate() {
        if (!this.isPlaying) return;
        
        this.drawFrame(this.currentFrame);
        this.currentFrame++;
        
        if (this.currentFrame >= this.frames.length) {
          // Animation complete - freeze on last frame
          this.freezeLastFrame();
          return;
        }
        
        // Continue animation
        setTimeout(() => {
          this.animationId = requestAnimationFrame(() => this.animate());
        }, this.frameDelay);
      }
      
      freezeLastFrame() {
        this.isPlaying = false;
        if (this.animationId) {
          cancelAnimationFrame(this.animationId);
        }
        
        // Draw the last frame
        const lastFrameIndex = this.frames.length - 1;
        this.drawFrame(lastFrameIndex);
        this.currentFrame = lastFrameIndex;
        
        this.updateStatus('Frozen on last frame');
        
        // Trigger your site transition here
        setTimeout(() => {
          this.onAnimationComplete();
        }, 1000);
      }
      
      drawFrame(frameIndex) {
        if (frameIndex < 0 || frameIndex >= this.frames.length) return;
        
        const frame = this.frames[frameIndex];
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.drawImage(frame, 0, 0);
      }
      
      updateStatus(message) {
        document.getElementById('status').textContent = message;
      }
      
      onAnimationComplete() {
        console.log('Animation complete! Transitioning to site...');
        // Your site transition code here
      }
    }

    // Initialize when page loads
    window.addEventListener('load', () => {
      // Replace with your actual GIF URL
      window.gifController = new GIFController('gifCanvas', 'https://via.placeholder.com/400x200/000000/ffffff?text=Your+GIF');
      
      // Auto-play after a short delay
      setTimeout(() => {
        gifController.play();
      }, 1000);
    });
  </script>
</body>
</html>
